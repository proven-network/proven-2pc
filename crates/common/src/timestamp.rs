//! Physical timestamp in microseconds since Unix epoch
//!
//! Used for stream entry timestamps, transaction deadlines, and MVCC snapshots.
//! Each logger enforces monotonicity via max(current_time, last_timestamp + 1).

use serde::{Deserialize, Serialize};
use std::fmt;
use std::time::{SystemTime, UNIX_EPOCH};

/// Physical timestamp in microseconds since Unix epoch
///
/// Used for:
/// - Stream entry timestamps (assigned by logger/stream)
/// - Transaction deadlines (generated by coordinator)
/// - MVCC snapshot reads
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
pub struct Timestamp(u64);

impl Timestamp {
    /// Create a timestamp from microseconds
    pub const fn from_micros(micros: u64) -> Self {
        Self(micros)
    }

    /// Get current timestamp
    pub fn now() -> Self {
        let micros = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_micros() as u64;
        Self(micros)
    }

    /// Get the raw microseconds value
    pub const fn as_micros(&self) -> u64 {
        self.0
    }

    /// Parse from string
    pub fn parse(s: &str) -> Result<Self, String> {
        s.parse::<u64>()
            .map(Self)
            .map_err(|e| format!("Invalid timestamp: {}", e))
    }

    /// Convert to bytes (8 bytes, big-endian for lexicographic ordering)
    pub fn to_bytes(&self) -> [u8; 8] {
        self.0.to_be_bytes()
    }

    /// Parse from bytes
    pub fn from_bytes(bytes: [u8; 8]) -> Self {
        Self(u64::from_be_bytes(bytes))
    }

    /// Add duration in microseconds
    pub fn add_micros(&self, micros: u64) -> Self {
        Self(self.0.saturating_add(micros))
    }

    /// Subtract duration in microseconds
    pub fn sub_micros(&self, micros: u64) -> Self {
        Self(self.0.saturating_sub(micros))
    }

    /// Duration since another timestamp in microseconds
    pub fn duration_since(&self, earlier: &Timestamp) -> u64 {
        self.0.saturating_sub(earlier.0)
    }

    /// Check if this timestamp is after another
    pub fn is_after(&self, other: &Timestamp) -> bool {
        self.0 > other.0
    }

    /// Check if this timestamp is before another
    pub fn is_before(&self, other: &Timestamp) -> bool {
        self.0 < other.0
    }
}

impl fmt::Display for Timestamp {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ordering() {
        let t1 = Timestamp::from_micros(1000);
        let t2 = Timestamp::from_micros(2000);
        assert!(t1 < t2);
        assert!(t2 > t1);
    }

    #[test]
    fn test_roundtrip_string() {
        let t = Timestamp::now();
        let s = t.to_string();
        let parsed = Timestamp::parse(&s).unwrap();
        assert_eq!(t, parsed);
    }

    #[test]
    fn test_roundtrip_bytes() {
        let t = Timestamp::from_micros(123456789);
        let bytes = t.to_bytes();
        let from_bytes = Timestamp::from_bytes(bytes);
        assert_eq!(t, from_bytes);
    }

    #[test]
    fn test_arithmetic() {
        let t = Timestamp::from_micros(1000);
        assert_eq!(t.add_micros(500).as_micros(), 1500);
        assert_eq!(t.sub_micros(200).as_micros(), 800);
    }

    #[test]
    fn test_duration_since() {
        let t1 = Timestamp::from_micros(1000);
        let t2 = Timestamp::from_micros(2500);
        assert_eq!(t2.duration_since(&t1), 1500);
    }

    #[test]
    fn test_is_after_before() {
        let t1 = Timestamp::from_micros(1000);
        let t2 = Timestamp::from_micros(2000);

        assert!(t2.is_after(&t1));
        assert!(!t1.is_after(&t2));

        assert!(t1.is_before(&t2));
        assert!(!t2.is_before(&t1));
    }

    #[test]
    fn test_saturating_arithmetic() {
        let t = Timestamp::from_micros(100);

        // Saturating sub doesn't underflow
        assert_eq!(t.sub_micros(200).as_micros(), 0);

        // Saturating add doesn't overflow
        let max = Timestamp::from_micros(u64::MAX);
        assert_eq!(max.add_micros(100).as_micros(), u64::MAX);
    }

    #[test]
    fn test_monotonicity_pattern() {
        // Test the monotonicity pattern used in stream.rs
        let mut last_timestamp = Timestamp::from_micros(1000);
        let now = Timestamp::from_micros(999); // Clock went backwards!

        // Monotonic enforcement: max(current_time, last_timestamp + 1)
        let timestamp = if last_timestamp >= now {
            Timestamp::from_micros(last_timestamp.as_micros() + 1)
        } else {
            now
        };

        assert_eq!(timestamp.as_micros(), 1001);
        assert!(timestamp > last_timestamp);

        last_timestamp = timestamp;

        // Normal case: time advances
        let now = Timestamp::from_micros(2000);
        let timestamp = if last_timestamp >= now {
            Timestamp::from_micros(last_timestamp.as_micros() + 1)
        } else {
            now
        };

        assert_eq!(timestamp.as_micros(), 2000);
    }

    #[test]
    fn test_lexicographic_bytes_ordering() {
        let t1 = Timestamp::from_micros(100);
        let t2 = Timestamp::from_micros(200);

        let bytes1 = t1.to_bytes();
        let bytes2 = t2.to_bytes();

        // Byte-wise comparison should match timestamp ordering
        assert!(bytes1 < bytes2);
    }
}
